import logging
import typing as t
from abc import ABC, abstractmethod

from globus_compute_sdk.errors import DeserializationError, SerializationError

logger = logging.getLogger(__name__)

# 2 unique characters and a newline
IDENTIFIER_LENGTH = 3


class SerializationStrategy(ABC):
    """
    A ``SerializationStrategy`` is in charge of converting function source code or
    arguments into string data and back again.
    """

    _CACHE: t.ClassVar[t.Dict[str, "SerializationStrategy"]] = {}

    def __init_subclass__(cls):
        super().__init_subclass__()
        if not hasattr(cls, "identifier"):
            return
        if len(cls.identifier) != IDENTIFIER_LENGTH:
            raise ValueError(f"Identifiers must be {IDENTIFIER_LENGTH} characters long")
        if cls.identifier[-1] != "\n":
            raise ValueError("Identifiers must end with a newline character")
        existing = SerializationStrategy._CACHE.get(cls.identifier)
        if existing:
            raise ValueError(
                f"Identifier {cls.identifier!r} is already used by"
                f" {type(existing).__name__}"
            )

        SerializationStrategy._CACHE[cls.identifier] = cls()

    #: The unique, 3-character string that identifies this strategy. The first two
    #: characters are the effective identifier; the third must always be the newline
    #: character ``"\n"``.
    identifier: t.ClassVar[str]
    #: If ``True``, this strategy works with callable Python objects - functions,
    #: classes that implement ``__call__``, etc. If ``False``, this strategy works with
    #: all other Python objects (ie, arguments and keyword arguments in submissions).
    #: Note that a single ``SerializationStrategy`` cannot support both callables and
    #: non-callables.
    for_code: t.ClassVar[bool]

    @classmethod
    def get_cached_by_id(cls, identifier: str) -> t.Optional["SerializationStrategy"]:
        return cls._CACHE.get(identifier)

    @classmethod
    def get_cached_by_class(
        cls, type_: t.Type["SerializationStrategy"]
    ) -> "SerializationStrategy":
        return cls._CACHE[type_.identifier]

    @abstractmethod
    def serialize(self, data: t.Any) -> str:
        """
        Converts arbitrary Python data to a string representation.

        :param data: If ``for_code``, any callable Python object; if not
            ``for_code``, any other Python object. Serializers are not
            guaranteed to work with every callable or non-callable object.

        :returns: The string representation, which can be deserialized again by an
            instance of this strategy.

        :raises: A ``SerializationStrategy`` may raise for various reasons if it
            cannot handle a given Python object.
        """
        raise NotImplementedError("Concrete class did not implement serialize")

    @abstractmethod
    def deserialize(self, payload: str) -> t.Any:
        """
        Converts serialized string data back into the Python object it represents.
        Inverse of ``serialize``.

        :param payload: Serialized data generated by an instance of this strategy.

        :returns: The Python object represented by the payload.

        :raises: If the payload wasn't serialized by an instance of this strategy, or
            if encountering other unexpected errors. May also raise if the payload was
            serialized with a different Python version than what is currently running.
        """
        raise NotImplementedError("Concrete class did not implement deserialize")

    def chomp(self, payload: str) -> str:
        """
        A helper function for stripping this strategy's header from a payload.

        :param payload: Python data serialized by this strategy.

        :raises: If the payload does not start with the expected header.
        """
        s_id, payload = payload.split("\n", 1)
        if (s_id + "\n") != self.identifier:
            raise DeserializationError(
                f"Buffer does not start with identifier:{self.identifier}"
            )
        return payload


class ComboSerializationStrategy(SerializationStrategy, ABC):
    """Combines serialized results from multiple strategies into a single payload.

    .. important::
        All sub-strategies must base64-encode their serialized data before prefixing
        it with a strategy identifier to avoid delimiter conflicts when deserializing.
    """

    strategies: t.ClassVar[list[t.Type[SerializationStrategy]]]
    _separator = "|"  # Will never appear in a base64 string

    def serialize(self, data: t.Any):
        ":meta private:"
        chunks, errors = [], []
        for strategy_cls in self.strategies:
            strategy: SerializationStrategy = self.get_cached_by_class(strategy_cls)

            try:
                serialized = strategy.serialize(data)
            except Exception as e:
                error_msg = f"{strategy_cls.__name__}: {e}"
                errors.append(error_msg)
                logger.debug(f"Failed to serialize with {error_msg}")
                continue

            chunks.append(serialized)

        if not chunks:
            errors_str = "\n* ".join(errors) if errors else "unknown"
            raise SerializationError(f"\n\nSerialization errors:\n* {errors_str}")

        return self.identifier + self._separator.join(chunks)

    def deserialize(self, payload: str):
        ":meta private:"
        chomped = self.chomp(payload)
        chunks = chomped.split(self._separator)
        errors = []
        for chunk in chunks:
            try:
                chunk_id, _ = chunk.split("\n", 1)
            except ValueError:
                suffix = "..." if len(chunk) > 50 else ""
                error_msg = (
                    f"Malformed data (no newline separator): {chunk[:50]}{suffix}"
                )
                errors.append(error_msg)
                logger.debug(error_msg)
                continue

            strategy = self.get_cached_by_id(chunk_id + "\n")
            if strategy is None:
                error_msg = f"Invalid strategy identifier: {chunk_id}"
                errors.append(error_msg)
                logger.debug(error_msg)
                continue

            try:
                return strategy.deserialize(chunk)
            except Exception as e:
                strategy_name = type(strategy).__name__
                error_msg = f"{strategy_name}: {e}"
                errors.append(error_msg)
                logger.debug(f"Failed to deserialize with {error_msg}")
                continue

        errors_str = "\n* ".join(errors) if errors else "unknown"
        raise DeserializationError(f"\n\nDeserialization errors:\n* {errors_str}")
