import typing as t
from abc import ABC, abstractmethod

from globus_compute_sdk.errors import DeserializationError

# 2 unique characters and a newline
IDENTIFIER_LENGTH = 3


class SerializationStrategy(ABC):
    """
    A ``SerializationStrategy`` is in charge of converting function source code or
    arguments into string data and back again.
    """

    _CACHE: t.ClassVar[t.Dict[str, "SerializationStrategy"]] = {}

    def __init_subclass__(cls):
        super().__init_subclass__()
        if len(cls.identifier) != IDENTIFIER_LENGTH:
            raise ValueError(f"Identifiers must be {IDENTIFIER_LENGTH} characters long")
        if cls.identifier[-1] != "\n":
            raise ValueError("Identifiers must end with a newline character")
        existing = SerializationStrategy._CACHE.get(cls.identifier)
        if existing:
            raise ValueError(
                f"Identifier {cls.identifier!r} is already used by"
                f" {type(existing).__name__}"
            )

        SerializationStrategy._CACHE[cls.identifier] = cls()

    #: The unique, 3-character string that identifies this strategy. The first two
    #: characters are the effective identifier; the third must always be the newline
    #: character ``"\n"``.
    identifier: t.ClassVar[str]
    #: If ``True``, this strategy works with callable Python objects - functions,
    #: classes that implement ``__call__``, etc. If ``False``, this strategy works with
    #: all other Python objects (ie, arguments and keyword arguments in submissions).
    #: Note that a single ``SerializationStrategy`` cannot support both callables and
    #: non-callables.
    for_code: t.ClassVar[bool]

    @classmethod
    def get_cached_by_id(cls, identifier: str) -> t.Optional["SerializationStrategy"]:
        return cls._CACHE.get(identifier)

    T = t.TypeVar("T", bound="SerializationStrategy")

    @classmethod
    def get_cached_by_class(cls, type_: t.Type[T]) -> T:
        return t.cast(SerializationStrategy.T, cls._CACHE[type_.identifier])

    @abstractmethod
    def serialize(self, data: t.Any) -> str:
        """
        Converts arbitrary Python data to a string representation.

        :param data: If ``for_code``, any callable Python object; if not
            ``for_code``, any other Python object. Serializers are not
            guaranteed to work with every callable or non-callable object.

        :returns: The string representation, which can be deserialized again by an
            instance of this strategy.

        :raises: A ``SerializationStrategy`` may raise for various reasons if it
            cannot handle a given Python object.
        """
        raise NotImplementedError("Concrete class did not implement serialize")

    @abstractmethod
    def deserialize(self, payload: str) -> t.Any:
        """
        Converts serialized string data back into the Python object it represents.
        Inverse of ``serialize``.

        :param payload: Serialized data generated by an instance of this strategy.

        :returns: The Python object represented by the payload.

        :raises: If the payload wasn't serialized by an instance of this strategy, or
            if encountering other unexpected errors. May also raise if the payload was
            serialized with a different Python version than what is currently running.
        """
        raise NotImplementedError("Concrete class did not implement deserialize")

    def chomp(self, payload: str) -> str:
        """
        A helper function for stripping this strategy's header from a payload.

        :param payload: Python data serialized by this strategy.

        :raises: If the payload does not start with the expected header.
        """
        s_id, payload = payload.split("\n", 1)
        if (s_id + "\n") != self.identifier:
            raise DeserializationError(
                f"Buffer does not start with identifier:{self.identifier}"
            )
        return payload
